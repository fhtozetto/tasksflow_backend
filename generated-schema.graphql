# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateBarcodes {
  _count: BarcodesCountAggregate
  _max: BarcodesMaxAggregate
  _min: BarcodesMinAggregate
}

type AggregateProducts {
  _count: ProductsCountAggregate
  _max: ProductsMaxAggregate
  _min: ProductsMinAggregate
}

type AggregateValidity {
  _count: ValidityCountAggregate
  _max: ValidityMaxAggregate
  _min: ValidityMinAggregate
}

type Barcodes {
  created_At: DateTime!
  id: String!
  product: Products
  product_id: String
}

type BarcodesCountAggregate {
  _all: Int!
  created_At: Int!
  id: Int!
  product_id: Int!
}

input BarcodesCountOrderByAggregateInput {
  created_At: SortOrder
  id: SortOrder
  product_id: SortOrder
}

input BarcodesCreateInput {
  created_At: DateTime
  id: String
  product: ProductsCreateNestedOneWithoutBarcodesInput
}

input BarcodesCreateManyInput {
  created_At: DateTime
  id: String
  product_id: String
}

input BarcodesCreateManyProductInput {
  created_At: DateTime
  id: String
}

input BarcodesCreateManyProductInputEnvelope {
  data: [BarcodesCreateManyProductInput!]!
  skipDuplicates: Boolean
}

input BarcodesCreateNestedManyWithoutProductInput {
  connect: [BarcodesWhereUniqueInput!]
  connectOrCreate: [BarcodesCreateOrConnectWithoutProductInput!]
  create: [BarcodesCreateWithoutProductInput!]
  createMany: BarcodesCreateManyProductInputEnvelope
}

input BarcodesCreateOrConnectWithoutProductInput {
  create: BarcodesCreateWithoutProductInput!
  where: BarcodesWhereUniqueInput!
}

input BarcodesCreateWithoutProductInput {
  created_At: DateTime
  id: String
}

type BarcodesGroupBy {
  _count: BarcodesCountAggregate
  _max: BarcodesMaxAggregate
  _min: BarcodesMinAggregate
  created_At: DateTime!
  id: String!
  product_id: String
}

input BarcodesListRelationFilter {
  every: BarcodesWhereInput
  none: BarcodesWhereInput
  some: BarcodesWhereInput
}

type BarcodesMaxAggregate {
  created_At: DateTime
  id: String
  product_id: String
}

input BarcodesMaxOrderByAggregateInput {
  created_At: SortOrder
  id: SortOrder
  product_id: SortOrder
}

type BarcodesMinAggregate {
  created_At: DateTime
  id: String
  product_id: String
}

input BarcodesMinOrderByAggregateInput {
  created_At: SortOrder
  id: SortOrder
  product_id: SortOrder
}

input BarcodesOrderByRelationAggregateInput {
  _count: SortOrder
}

input BarcodesOrderByWithAggregationInput {
  _count: BarcodesCountOrderByAggregateInput
  _max: BarcodesMaxOrderByAggregateInput
  _min: BarcodesMinOrderByAggregateInput
  created_At: SortOrder
  id: SortOrder
  product_id: SortOrder
}

input BarcodesOrderByWithRelationInput {
  created_At: SortOrder
  id: SortOrder
  product: ProductsOrderByWithRelationInput
  product_id: SortOrder
}

enum BarcodesScalarFieldEnum {
  created_At
  id
  product_id
}

input BarcodesScalarWhereInput {
  AND: [BarcodesScalarWhereInput!]
  created_At: DateTimeFilter
  id: StringFilter
  NOT: [BarcodesScalarWhereInput!]
  OR: [BarcodesScalarWhereInput!]
  product_id: StringNullableFilter
}

input BarcodesScalarWhereWithAggregatesInput {
  AND: [BarcodesScalarWhereWithAggregatesInput!]
  created_At: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  NOT: [BarcodesScalarWhereWithAggregatesInput!]
  OR: [BarcodesScalarWhereWithAggregatesInput!]
  product_id: StringNullableWithAggregatesFilter
}

input BarcodesUpdateInput {
  created_At: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  product: ProductsUpdateOneWithoutBarcodesInput
}

input BarcodesUpdateManyMutationInput {
  created_At: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input BarcodesUpdateManyWithoutProductInput {
  connect: [BarcodesWhereUniqueInput!]
  connectOrCreate: [BarcodesCreateOrConnectWithoutProductInput!]
  create: [BarcodesCreateWithoutProductInput!]
  createMany: BarcodesCreateManyProductInputEnvelope
  delete: [BarcodesWhereUniqueInput!]
  deleteMany: [BarcodesScalarWhereInput!]
  disconnect: [BarcodesWhereUniqueInput!]
  set: [BarcodesWhereUniqueInput!]
  update: [BarcodesUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [BarcodesUpdateManyWithWhereWithoutProductInput!]
  upsert: [BarcodesUpsertWithWhereUniqueWithoutProductInput!]
}

input BarcodesUpdateManyWithWhereWithoutProductInput {
  data: BarcodesUpdateManyMutationInput!
  where: BarcodesScalarWhereInput!
}

input BarcodesUpdateWithoutProductInput {
  created_At: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input BarcodesUpdateWithWhereUniqueWithoutProductInput {
  data: BarcodesUpdateWithoutProductInput!
  where: BarcodesWhereUniqueInput!
}

input BarcodesUpsertWithWhereUniqueWithoutProductInput {
  create: BarcodesCreateWithoutProductInput!
  update: BarcodesUpdateWithoutProductInput!
  where: BarcodesWhereUniqueInput!
}

input BarcodesWhereInput {
  AND: [BarcodesWhereInput!]
  created_At: DateTimeFilter
  id: StringFilter
  NOT: [BarcodesWhereInput!]
  OR: [BarcodesWhereInput!]
  product: ProductsRelationFilter
  product_id: StringNullableFilter
}

input BarcodesWhereUniqueInput {
  id: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Mutation {
  createBarcodes(data: BarcodesCreateInput!): Barcodes!
  createManyBarcodes(data: [BarcodesCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyProducts(data: [ProductsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyValidity(data: [ValidityCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createProducts(data: ProductsCreateInput!): Products!
  createValidity(data: ValidityCreateInput!): Validity!
  deleteBarcodes(where: BarcodesWhereUniqueInput!): Barcodes
  deleteManyBarcodes(where: BarcodesWhereInput): AffectedRowsOutput!
  deleteManyProducts(where: ProductsWhereInput): AffectedRowsOutput!
  deleteManyValidity(where: ValidityWhereInput): AffectedRowsOutput!
  deleteProducts(where: ProductsWhereUniqueInput!): Products
  deleteValidity(where: ValidityWhereUniqueInput!): Validity
  updateBarcodes(data: BarcodesUpdateInput!, where: BarcodesWhereUniqueInput!): Barcodes
  updateManyBarcodes(data: BarcodesUpdateManyMutationInput!, where: BarcodesWhereInput): AffectedRowsOutput!
  updateManyProducts(data: ProductsUpdateManyMutationInput!, where: ProductsWhereInput): AffectedRowsOutput!
  updateManyValidity(data: ValidityUpdateManyMutationInput!, where: ValidityWhereInput): AffectedRowsOutput!
  updateProducts(data: ProductsUpdateInput!, where: ProductsWhereUniqueInput!): Products
  updateValidity(data: ValidityUpdateInput!, where: ValidityWhereUniqueInput!): Validity
  upsertBarcodes(create: BarcodesCreateInput!, update: BarcodesUpdateInput!, where: BarcodesWhereUniqueInput!): Barcodes!
  upsertProducts(create: ProductsCreateInput!, update: ProductsUpdateInput!, where: ProductsWhereUniqueInput!): Products!
  upsertValidity(create: ValidityCreateInput!, update: ValidityUpdateInput!, where: ValidityWhereUniqueInput!): Validity!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Products {
  _count: ProductsCount
  Barcodes(cursor: BarcodesWhereUniqueInput, distinct: [BarcodesScalarFieldEnum!], orderBy: [BarcodesOrderByWithRelationInput!], skip: Int, take: Int, where: BarcodesWhereInput): [Barcodes!]!
  created_at: DateTime!
  description: String
  erp_code: String!
  id: String!
  Validity(cursor: ValidityWhereUniqueInput, distinct: [ValidityScalarFieldEnum!], orderBy: [ValidityOrderByWithRelationInput!], skip: Int, take: Int, where: ValidityWhereInput): [Validity!]!
}

type ProductsCount {
  Barcodes: Int!
  Validity: Int!
}

type ProductsCountAggregate {
  _all: Int!
  created_at: Int!
  description: Int!
  erp_code: Int!
  id: Int!
}

input ProductsCountOrderByAggregateInput {
  created_at: SortOrder
  description: SortOrder
  erp_code: SortOrder
  id: SortOrder
}

input ProductsCreateInput {
  Barcodes: BarcodesCreateNestedManyWithoutProductInput
  created_at: DateTime
  description: String
  erp_code: String!
  id: String
  Validity: ValidityCreateNestedManyWithoutProductInput
}

input ProductsCreateManyInput {
  created_at: DateTime
  description: String
  erp_code: String!
  id: String
}

input ProductsCreateNestedOneWithoutBarcodesInput {
  connect: ProductsWhereUniqueInput
  connectOrCreate: ProductsCreateOrConnectWithoutBarcodesInput
  create: ProductsCreateWithoutBarcodesInput
}

input ProductsCreateNestedOneWithoutValidityInput {
  connect: ProductsWhereUniqueInput
  connectOrCreate: ProductsCreateOrConnectWithoutValidityInput
  create: ProductsCreateWithoutValidityInput
}

input ProductsCreateOrConnectWithoutBarcodesInput {
  create: ProductsCreateWithoutBarcodesInput!
  where: ProductsWhereUniqueInput!
}

input ProductsCreateOrConnectWithoutValidityInput {
  create: ProductsCreateWithoutValidityInput!
  where: ProductsWhereUniqueInput!
}

input ProductsCreateWithoutBarcodesInput {
  created_at: DateTime
  description: String
  erp_code: String!
  id: String
  Validity: ValidityCreateNestedManyWithoutProductInput
}

input ProductsCreateWithoutValidityInput {
  Barcodes: BarcodesCreateNestedManyWithoutProductInput
  created_at: DateTime
  description: String
  erp_code: String!
  id: String
}

type ProductsGroupBy {
  _count: ProductsCountAggregate
  _max: ProductsMaxAggregate
  _min: ProductsMinAggregate
  created_at: DateTime!
  description: String
  erp_code: String!
  id: String!
}

type ProductsMaxAggregate {
  created_at: DateTime
  description: String
  erp_code: String
  id: String
}

input ProductsMaxOrderByAggregateInput {
  created_at: SortOrder
  description: SortOrder
  erp_code: SortOrder
  id: SortOrder
}

type ProductsMinAggregate {
  created_at: DateTime
  description: String
  erp_code: String
  id: String
}

input ProductsMinOrderByAggregateInput {
  created_at: SortOrder
  description: SortOrder
  erp_code: SortOrder
  id: SortOrder
}

input ProductsOrderByWithAggregationInput {
  _count: ProductsCountOrderByAggregateInput
  _max: ProductsMaxOrderByAggregateInput
  _min: ProductsMinOrderByAggregateInput
  created_at: SortOrder
  description: SortOrder
  erp_code: SortOrder
  id: SortOrder
}

input ProductsOrderByWithRelationInput {
  Barcodes: BarcodesOrderByRelationAggregateInput
  created_at: SortOrder
  description: SortOrder
  erp_code: SortOrder
  id: SortOrder
  Validity: ValidityOrderByRelationAggregateInput
}

input ProductsRelationFilter {
  is: ProductsWhereInput
  isNot: ProductsWhereInput
}

enum ProductsScalarFieldEnum {
  created_at
  description
  erp_code
  id
}

input ProductsScalarWhereWithAggregatesInput {
  AND: [ProductsScalarWhereWithAggregatesInput!]
  created_at: DateTimeWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  erp_code: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  NOT: [ProductsScalarWhereWithAggregatesInput!]
  OR: [ProductsScalarWhereWithAggregatesInput!]
}

input ProductsUpdateInput {
  Barcodes: BarcodesUpdateManyWithoutProductInput
  created_at: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  erp_code: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  Validity: ValidityUpdateManyWithoutProductInput
}

input ProductsUpdateManyMutationInput {
  created_at: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  erp_code: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input ProductsUpdateOneWithoutBarcodesInput {
  connect: ProductsWhereUniqueInput
  connectOrCreate: ProductsCreateOrConnectWithoutBarcodesInput
  create: ProductsCreateWithoutBarcodesInput
  delete: Boolean
  disconnect: Boolean
  update: ProductsUpdateWithoutBarcodesInput
  upsert: ProductsUpsertWithoutBarcodesInput
}

input ProductsUpdateOneWithoutValidityInput {
  connect: ProductsWhereUniqueInput
  connectOrCreate: ProductsCreateOrConnectWithoutValidityInput
  create: ProductsCreateWithoutValidityInput
  delete: Boolean
  disconnect: Boolean
  update: ProductsUpdateWithoutValidityInput
  upsert: ProductsUpsertWithoutValidityInput
}

input ProductsUpdateWithoutBarcodesInput {
  created_at: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  erp_code: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  Validity: ValidityUpdateManyWithoutProductInput
}

input ProductsUpdateWithoutValidityInput {
  Barcodes: BarcodesUpdateManyWithoutProductInput
  created_at: DateTimeFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  erp_code: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input ProductsUpsertWithoutBarcodesInput {
  create: ProductsCreateWithoutBarcodesInput!
  update: ProductsUpdateWithoutBarcodesInput!
}

input ProductsUpsertWithoutValidityInput {
  create: ProductsCreateWithoutValidityInput!
  update: ProductsUpdateWithoutValidityInput!
}

input ProductsWhereInput {
  AND: [ProductsWhereInput!]
  Barcodes: BarcodesListRelationFilter
  created_at: DateTimeFilter
  description: StringNullableFilter
  erp_code: StringFilter
  id: StringFilter
  NOT: [ProductsWhereInput!]
  OR: [ProductsWhereInput!]
  Validity: ValidityListRelationFilter
}

input ProductsWhereUniqueInput {
  id: String
}

type Query {
  aggregateBarcodes(cursor: BarcodesWhereUniqueInput, orderBy: [BarcodesOrderByWithRelationInput!], skip: Int, take: Int, where: BarcodesWhereInput): AggregateBarcodes!
  aggregateProducts(cursor: ProductsWhereUniqueInput, orderBy: [ProductsOrderByWithRelationInput!], skip: Int, take: Int, where: ProductsWhereInput): AggregateProducts!
  aggregateValidity(cursor: ValidityWhereUniqueInput, orderBy: [ValidityOrderByWithRelationInput!], skip: Int, take: Int, where: ValidityWhereInput): AggregateValidity!
  findFirstBarcodes(cursor: BarcodesWhereUniqueInput, distinct: [BarcodesScalarFieldEnum!], orderBy: [BarcodesOrderByWithRelationInput!], skip: Int, take: Int, where: BarcodesWhereInput): Barcodes
  findFirstProducts(cursor: ProductsWhereUniqueInput, distinct: [ProductsScalarFieldEnum!], orderBy: [ProductsOrderByWithRelationInput!], skip: Int, take: Int, where: ProductsWhereInput): Products
  findFirstValidity(cursor: ValidityWhereUniqueInput, distinct: [ValidityScalarFieldEnum!], orderBy: [ValidityOrderByWithRelationInput!], skip: Int, take: Int, where: ValidityWhereInput): Validity
  findManyBarcodes(cursor: BarcodesWhereUniqueInput, distinct: [BarcodesScalarFieldEnum!], orderBy: [BarcodesOrderByWithRelationInput!], skip: Int, take: Int, where: BarcodesWhereInput): [Barcodes!]!
  findManyProducts(cursor: ProductsWhereUniqueInput, distinct: [ProductsScalarFieldEnum!], orderBy: [ProductsOrderByWithRelationInput!], skip: Int, take: Int, where: ProductsWhereInput): [Products!]!
  findUniqueBarcodes(where: BarcodesWhereUniqueInput!): Barcodes
  findUniqueProducts(where: ProductsWhereUniqueInput!): Products
  groupByBarcodes(by: [BarcodesScalarFieldEnum!]!, having: BarcodesScalarWhereWithAggregatesInput, orderBy: [BarcodesOrderByWithAggregationInput!], skip: Int, take: Int, where: BarcodesWhereInput): [BarcodesGroupBy!]!
  groupByProducts(by: [ProductsScalarFieldEnum!]!, having: ProductsScalarWhereWithAggregatesInput, orderBy: [ProductsOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductsWhereInput): [ProductsGroupBy!]!
  groupByValidity(by: [ValidityScalarFieldEnum!]!, having: ValidityScalarWhereWithAggregatesInput, orderBy: [ValidityOrderByWithAggregationInput!], skip: Int, take: Int, where: ValidityWhereInput): [ValidityGroupBy!]!
  validities(cursor: ValidityWhereUniqueInput, distinct: [ValidityScalarFieldEnum!], orderBy: [ValidityOrderByWithRelationInput!], skip: Int, take: Int, where: ValidityWhereInput): [Validity!]!
  validity(where: ValidityWhereUniqueInput!): Validity
}

enum QueryMode {
  default
  insensitive
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Validity {
  created_at: DateTime!
  due_date: DateTime
  finished_at: DateTime!
  id: String!
  product: Products
  product_id: String
}

type ValidityCountAggregate {
  _all: Int!
  created_at: Int!
  due_date: Int!
  finished_at: Int!
  id: Int!
  product_id: Int!
}

input ValidityCountOrderByAggregateInput {
  created_at: SortOrder
  due_date: SortOrder
  finished_at: SortOrder
  id: SortOrder
  product_id: SortOrder
}

input ValidityCreateInput {
  created_at: DateTime
  due_date: DateTime
  finished_at: DateTime!
  id: String
  product: ProductsCreateNestedOneWithoutValidityInput
}

input ValidityCreateManyInput {
  created_at: DateTime
  due_date: DateTime
  finished_at: DateTime!
  id: String
  product_id: String
}

input ValidityCreateManyProductInput {
  created_at: DateTime
  due_date: DateTime
  finished_at: DateTime!
  id: String
}

input ValidityCreateManyProductInputEnvelope {
  data: [ValidityCreateManyProductInput!]!
  skipDuplicates: Boolean
}

input ValidityCreateNestedManyWithoutProductInput {
  connect: [ValidityWhereUniqueInput!]
  connectOrCreate: [ValidityCreateOrConnectWithoutProductInput!]
  create: [ValidityCreateWithoutProductInput!]
  createMany: ValidityCreateManyProductInputEnvelope
}

input ValidityCreateOrConnectWithoutProductInput {
  create: ValidityCreateWithoutProductInput!
  where: ValidityWhereUniqueInput!
}

input ValidityCreateWithoutProductInput {
  created_at: DateTime
  due_date: DateTime
  finished_at: DateTime!
  id: String
}

type ValidityGroupBy {
  _count: ValidityCountAggregate
  _max: ValidityMaxAggregate
  _min: ValidityMinAggregate
  created_at: DateTime!
  due_date: DateTime
  finished_at: DateTime!
  id: String!
  product_id: String
}

input ValidityListRelationFilter {
  every: ValidityWhereInput
  none: ValidityWhereInput
  some: ValidityWhereInput
}

type ValidityMaxAggregate {
  created_at: DateTime
  due_date: DateTime
  finished_at: DateTime
  id: String
  product_id: String
}

input ValidityMaxOrderByAggregateInput {
  created_at: SortOrder
  due_date: SortOrder
  finished_at: SortOrder
  id: SortOrder
  product_id: SortOrder
}

type ValidityMinAggregate {
  created_at: DateTime
  due_date: DateTime
  finished_at: DateTime
  id: String
  product_id: String
}

input ValidityMinOrderByAggregateInput {
  created_at: SortOrder
  due_date: SortOrder
  finished_at: SortOrder
  id: SortOrder
  product_id: SortOrder
}

input ValidityOrderByRelationAggregateInput {
  _count: SortOrder
}

input ValidityOrderByWithAggregationInput {
  _count: ValidityCountOrderByAggregateInput
  _max: ValidityMaxOrderByAggregateInput
  _min: ValidityMinOrderByAggregateInput
  created_at: SortOrder
  due_date: SortOrder
  finished_at: SortOrder
  id: SortOrder
  product_id: SortOrder
}

input ValidityOrderByWithRelationInput {
  created_at: SortOrder
  due_date: SortOrder
  finished_at: SortOrder
  id: SortOrder
  product: ProductsOrderByWithRelationInput
  product_id: SortOrder
}

enum ValidityScalarFieldEnum {
  created_at
  due_date
  finished_at
  id
  product_id
}

input ValidityScalarWhereInput {
  AND: [ValidityScalarWhereInput!]
  created_at: DateTimeFilter
  due_date: DateTimeNullableFilter
  finished_at: DateTimeFilter
  id: StringFilter
  NOT: [ValidityScalarWhereInput!]
  OR: [ValidityScalarWhereInput!]
  product_id: StringNullableFilter
}

input ValidityScalarWhereWithAggregatesInput {
  AND: [ValidityScalarWhereWithAggregatesInput!]
  created_at: DateTimeWithAggregatesFilter
  due_date: DateTimeNullableWithAggregatesFilter
  finished_at: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  NOT: [ValidityScalarWhereWithAggregatesInput!]
  OR: [ValidityScalarWhereWithAggregatesInput!]
  product_id: StringNullableWithAggregatesFilter
}

input ValidityUpdateInput {
  created_at: DateTimeFieldUpdateOperationsInput
  due_date: NullableDateTimeFieldUpdateOperationsInput
  finished_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  product: ProductsUpdateOneWithoutValidityInput
}

input ValidityUpdateManyMutationInput {
  created_at: DateTimeFieldUpdateOperationsInput
  due_date: NullableDateTimeFieldUpdateOperationsInput
  finished_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input ValidityUpdateManyWithoutProductInput {
  connect: [ValidityWhereUniqueInput!]
  connectOrCreate: [ValidityCreateOrConnectWithoutProductInput!]
  create: [ValidityCreateWithoutProductInput!]
  createMany: ValidityCreateManyProductInputEnvelope
  delete: [ValidityWhereUniqueInput!]
  deleteMany: [ValidityScalarWhereInput!]
  disconnect: [ValidityWhereUniqueInput!]
  set: [ValidityWhereUniqueInput!]
  update: [ValidityUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [ValidityUpdateManyWithWhereWithoutProductInput!]
  upsert: [ValidityUpsertWithWhereUniqueWithoutProductInput!]
}

input ValidityUpdateManyWithWhereWithoutProductInput {
  data: ValidityUpdateManyMutationInput!
  where: ValidityScalarWhereInput!
}

input ValidityUpdateWithoutProductInput {
  created_at: DateTimeFieldUpdateOperationsInput
  due_date: NullableDateTimeFieldUpdateOperationsInput
  finished_at: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input ValidityUpdateWithWhereUniqueWithoutProductInput {
  data: ValidityUpdateWithoutProductInput!
  where: ValidityWhereUniqueInput!
}

input ValidityUpsertWithWhereUniqueWithoutProductInput {
  create: ValidityCreateWithoutProductInput!
  update: ValidityUpdateWithoutProductInput!
  where: ValidityWhereUniqueInput!
}

input ValidityWhereInput {
  AND: [ValidityWhereInput!]
  created_at: DateTimeFilter
  due_date: DateTimeNullableFilter
  finished_at: DateTimeFilter
  id: StringFilter
  NOT: [ValidityWhereInput!]
  OR: [ValidityWhereInput!]
  product: ProductsRelationFilter
  product_id: StringNullableFilter
}

input ValidityWhereUniqueInput {
  id: String
}
